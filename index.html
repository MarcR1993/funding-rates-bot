<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funding Rates Monitor - PythonAnywhere Live</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            color: white;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .status {
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .status.connected {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .status.disconnected {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        .last-update {
            color: white;
            font-size: 14px;
            opacity: 0.9;
        }

        .refresh-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .add-crypto-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .add-crypto-form {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .crypto-input {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .crypto-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .add-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .tracked-symbols {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .symbol-tag {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .remove-symbol {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .section-header h2 {
            color: #2c3e50;
            font-size: 1.8em;
            font-weight: 700;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .legend span {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #555;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .table-container {
            overflow-x: auto;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 15px;
            overflow: hidden;
        }

        th, td {
            padding: 15px 20px;
            text-align: center;
            border-bottom: 1px solid #f0f0f0;
        }

        th {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .symbol-cell {
            font-weight: 700;
            font-size: 16px;
            color: #2c3e50;
        }

        .positive {
            color: #27ae60;
            font-weight: 600;
        }

        .negative {
            color: #e74c3c;
            font-weight: 600;
        }

        .neutral {
            color: #7f8c8d;
            font-style: italic;
        }

        .loading {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 30px;
        }

        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .exchange-status {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .exchange-badge {
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .exchange-badge.online {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .exchange-badge.offline {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .status-bar {
                gap: 15px;
            }
            
            .section {
                padding: 20px;
            }
            
            .section-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .legend {
                gap: 15px;
            }
            
            th, td {
                padding: 10px 8px;
                font-size: 12px;
            }

            .add-crypto-form {
                flex-direction: column;
                align-items: stretch;
            }

            .crypto-input {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üí∞ Funding Rates Monitor - Live Data</h1>
            <div class="status-bar">
                <div id="connection-status" class="status disconnected">Connecting to PythonAnywhere...</div>
                <div style="background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; padding: 8px 16px; border-radius: 20px; font-size: 13px; font-weight: 600;">üêç Powered by PythonAnywhere</div>
                <div id="last-update" class="last-update">Never</div>
                <button id="refresh-btn" class="refresh-btn" onclick="forceRefresh()">üîÑ Refresh</button>
            </div>
        </div>

        <!-- Debug Section (will be hidden in production) -->
        <div class="section" id="debug-section" style="display: none;">
            <h3>üîß Debug Information</h3>
            <div class="debug-info" id="debug-info">
                Debug info will appear here...
            </div>
        </div>

        <!-- Add Crypto Section -->
        <div class="add-crypto-section">
            <h3 style="margin-bottom: 15px; color: #2c3e50;">üìà Add Cryptocurrency to Track</h3>
            <div class="add-crypto-form">
                <input 
                    type="text" 
                    id="crypto-input" 
                    class="crypto-input" 
                    placeholder="Enter symbol (e.g., BTC)"
                    maxlength="10"
                >
                <button onclick="addCrypto()" class="add-btn">‚ûï Add Symbol</button>
                <span style="color: #666; font-size: 12px;">
                    Live APIs: Binance, KuCoin, Bybit, OKX<br>
                    <small style="color: #999;">‚ö†Ô∏è Symbols reset on page reload (session only)</small>
                </span>
            </div>
            <div class="tracked-symbols" id="tracked-symbols">
                <!-- Tracked symbols will appear here -->
            </div>
        </div>

        <!-- Exchange Status Section -->
        <div class="section">
            <div class="section-header">
                <h2>üîó Exchange Status</h2>
                <div style="color: #666; font-size: 12px;">Backend: MarcR1993.pythonanywhere.com</div>
            </div>
            <div class="exchange-status" id="exchange-status">
                <div class="exchange-badge offline">
                    <span>üü°</span> Binance: Checking...
                </div>
                <div class="exchange-badge offline">
                    <span>üü°</span> KuCoin: Checking...
                </div>
                <div class="exchange-badge offline">
                    <span>üü°</span> Bybit: Checking...
                </div>
                <div class="exchange-badge offline">
                    <span>üü°</span> OKX: Checking...
                </div>
            </div>
        </div>

        <!-- Funding Rates Section -->
        <div class="section">
            <div class="section-header">
                <h2>üìä Current Funding Rates</h2>
                <div class="legend">
                    <span><span class="legend-dot" style="background: #f39c12;"></span> Binance</span>
                    <span><span class="legend-dot" style="background: #2ecc71;"></span> KuCoin</span>
                    <span><span class="legend-dot" style="background: #3498db;"></span> Bybit</span>
                    <span><span class="legend-dot" style="background: #9b59b6;"></span> OKX</span>
                </div>
            </div>
            <div class="table-container">
                <table class="funding-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Binance</th>
                            <th>KuCoin</th>
                            <th>Bybit</th>
                            <th>OKX</th>
                        </tr>
                    </thead>
                    <tbody id="funding-rates-body">
                        <tr><td colspan="5" class="loading">Connecting to PythonAnywhere backend...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // üöÄ Configuration - Your actual PythonAnywhere backend
        const BACKEND_URL = 'https://MarcR1993.pythonanywhere.com';
        
        let fundingRatesData = [];
        let trackedSymbols = ['BTC', 'ETH', 'SOL', 'XRP', 'DOGE', 'ADA', 'AVAX', 'MATIC', 'LINK', 'DOT'];
        let debugMode = false; // Set to true to see debug info

        console.log('üöÄ Funding Rates Monitor - PythonAnywhere Edition');
        console.log('üîó Backend URL:', BACKEND_URL);
        console.log('üìä Tracked symbols:', trackedSymbols);

        // Debug function
        function debugLog(message, data = null) {
            console.log(message, data);
            if (debugMode) {
                const debugDiv = document.getElementById('debug-info');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}${data ? '\n' + JSON.stringify(data, null, 2) : ''}\n\n`;
                debugDiv.textContent = logEntry + debugDiv.textContent;
                document.getElementById('debug-section').style.display = 'block';
            }
        }

        // Toggle debug mode
        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debug-section').style.display = debugMode ? 'block' : 'none';
            debugLog('Debug mode toggled', { debugMode });
        }

        // Update connection status
        function updateStatus(message, isConnected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = message;
            statusElement.className = isConnected ? 'status connected' : 'status disconnected';
            debugLog('Status updated', { message, isConnected });
        }

        // Load tracked symbols
        function loadTrackedSymbols() {
            updateTrackedSymbolsDisplay();
        }

        // Update tracked symbols display
        function updateTrackedSymbolsDisplay() {
            const container = document.getElementById('tracked-symbols');
            container.innerHTML = trackedSymbols.map(symbol => `
                <div class="symbol-tag">
                    ${symbol}
                    <button class="remove-symbol" onclick="removeSymbol('${symbol}')">√ó</button>
                </div>
            `).join('');
        }

        // Add crypto symbol
        function addCrypto() {
            const input = document.getElementById('crypto-input');
            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                alert('Please enter a symbol');
                return;
            }

            if (symbol.length > 10) {
                alert('Symbol too long (max 10 characters)');
                return;
            }

            if (trackedSymbols.includes(symbol)) {
                alert('Symbol already tracked');
                return;
            }

            trackedSymbols.push(symbol);
            updateTrackedSymbolsDisplay();
            input.value = '';
            debugLog('Symbol added', { symbol, trackedSymbols });

            // Reload data
            loadData();
        }

        // Remove symbol
        function removeSymbol(symbol) {
            trackedSymbols = trackedSymbols.filter(s => s !== symbol);
            updateTrackedSymbolsDisplay();
            debugLog('Symbol removed', { symbol, trackedSymbols });
            loadData();
        }

        // Format funding rate
        function formatRate(rate) {
            if (rate === null || rate === undefined || rate === '') return '-';
            const numRate = parseFloat(rate);
            if (isNaN(numRate)) return '-';
            return (numRate * 100).toFixed(4) + '%';
        }

        // Get CSS class for rate
        function getRateClass(rate) {
            if (rate === null || rate === undefined || rate === '') return 'neutral';
            const numRate = parseFloat(rate);
            if (isNaN(numRate)) return 'neutral';
            return numRate >= 0 ? 'positive' : 'negative';
        }

        // Update last update time
        function updateLastUpdateTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('last-update').textContent = `Updated: ${timeString}`;
        }

        // Update exchange status
        function updateExchangeStatus(exchangeStatus) {
            const container = document.getElementById('exchange-status');
            const exchanges = ['binance', 'kucoin', 'bybit', 'okx'];
            
            debugLog('Updating exchange status', exchangeStatus);
            
            container.innerHTML = exchanges.map(exchange => {
                const status = exchangeStatus[exchange] || { status: 'unknown' };
                const isOnline = status.status === 'success';
                const badgeClass = isOnline ? 'online' : 'offline';
                const icon = isOnline ? 'üü¢' : 'üî¥';
                const count = status.count || 0;
                
                return `
                    <div class="exchange-badge ${badgeClass}">
                        <span>${icon}</span> 
                        ${exchange.charAt(0).toUpperCase() + exchange.slice(1)}: 
                        ${isOnline ? `${count} rates` : 'Offline'}
                    </div>
                `;
            }).join('');
        }

        // Process backend data - FIXED VERSION
        function processBackendData(data) {
            debugLog('Raw backend data received', data);
            
            // Handle different data structures
            let dataArray = [];
            if (Array.isArray(data)) {
                dataArray = data;
            } else if (data && Array.isArray(data.data)) {
                dataArray = data.data;
            } else if (data && typeof data === 'object') {
                // If data is an object, try to extract array from common properties
                dataArray = data.rates || data.funding_rates || data.results || [];
            }

            debugLog('Extracted data array', { length: dataArray.length, sample: dataArray.slice(0, 3) });

            if (!Array.isArray(dataArray) || dataArray.length === 0) {
                debugLog('No valid data array found');
                return [];
            }

            // Group data by symbol
            const grouped = {};
            
            dataArray.forEach((item, index) => {
                debugLog(`Processing item ${index}`, item);
                
                // Extract symbol - try multiple possible field names
                let baseSymbol = item.base_symbol || 
                                item.symbol?.split('/')[0] || 
                                item.symbol?.split('USDT')[0] ||
                                item.symbol?.split('USDT')[0] ||
                                item.symbol?.replace('USDT', '') ||
                                item.symbol ||
                                item.asset ||
                                item.coin;

                if (!baseSymbol) {
                    debugLog(`No symbol found for item ${index}`, item);
                    return;
                }

                baseSymbol = baseSymbol.toUpperCase();

                // Only process symbols we're tracking
                if (!trackedSymbols.includes(baseSymbol)) {
                    return;
                }

                // Extract exchange name
                let exchange = (item.exchange || '').toLowerCase();
                
                // Extract funding rate - try multiple field names
                let rate = item.fundingRate || 
                          item.funding_rate || 
                          item.rate || 
                          item.current_rate ||
                          item.value;

                if (rate !== null && rate !== undefined) {
                    rate = parseFloat(rate);
                    if (isNaN(rate)) rate = null;
                }

                debugLog(`Processed item: ${baseSymbol} @ ${exchange} = ${rate}`);

                // Initialize symbol group
                if (!grouped[baseSymbol]) {
                    grouped[baseSymbol] = {
                        symbol: baseSymbol,
                        binance: null,
                        kucoin: null,
                        bybit: null,
                        okx: null
                    };
                }

                // Map exchange names
                const exchangeMap = {
                    'binance': 'binance',
                    'kucoin': 'kucoin', 
                    'ku': 'kucoin',
                    'bybit': 'bybit',
                    'okx': 'okx',
                    'okex': 'okx'
                };

                const mappedExchange = exchangeMap[exchange];
                if (mappedExchange && grouped[baseSymbol]) {
                    grouped[baseSymbol][mappedExchange] = rate;
                    debugLog(`Mapped ${exchange} -> ${mappedExchange} for ${baseSymbol}: ${rate}`);
                }
            });

            const result = Object.values(grouped);
            debugLog('Final processed data', { symbols: result.length, data: result });
            return result;
        }

        // Render funding rates table
        function renderFundingRatesTable() {
            const tbody = document.getElementById('funding-rates-body');
            
            debugLog('Rendering table', { dataLength: fundingRatesData.length });
            
            if (fundingRatesData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="loading">No data available for tracked symbols</td></tr>';
                return;
            }
            
            const rows = fundingRatesData.map((item, index) => {
                const symbol = item.symbol || `Symbol_${index}`;
                
                debugLog(`Rendering row for ${symbol}`, item);
                
                return `
                    <tr>
                        <td class="symbol-cell">${symbol}</td>
                        <td class="${getRateClass(item.binance)}">${formatRate(item.binance)}</td>
                        <td class="${getRateClass(item.kucoin)}">${formatRate(item.kucoin)}</td>
                        <td class="${getRateClass(item.bybit)}">${formatRate(item.bybit)}</td>
                        <td class="${getRateClass(item.okx)}">${formatRate(item.okx)}</td>
                    </tr>
                `;
            }).join('');
            
            tbody.innerHTML = rows;
            updateLastUpdateTime();
            debugLog('Table rendered successfully');
        }

        // Test backend connectivity
        async function testBackendConnectivity() {
            try {
                updateStatus('üîç Testing PythonAnywhere connectivity...', false);
                debugLog('Testing backend connectivity...');
                
                const response = await fetch(`${BACKEND_URL}/health`, {
                    method: 'GET',
                    mode: 'cors',
                    headers: { 'Accept': 'application/json' },
                    signal: AbortSignal.timeout(10000)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    updateStatus('‚úÖ PythonAnywhere connected', true);
                    debugLog('Backend health check passed', data);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                debugLog('Backend connectivity test failed', error);
                updateStatus(`üî¥ Backend error: ${error.message}`, false);
                return false;
            }
        }

        // Fetch funding rates from PythonAnywhere
        async function fetchFundingRates() {
            try {
                updateStatus('üîÑ Fetching live data from PythonAnywhere...', false);
                debugLog('Fetching funding rates...');
                
                const fullUrl = `${BACKEND_URL}/api/funding-rates`;
                debugLog('Fetching from URL', fullUrl);
                
                const response = await fetch(fullUrl, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    signal: AbortSignal.timeout(15000)
                });
                
                debugLog('Response received', { 
                    status: response.status, 
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const responseData = await response.json();
                debugLog('Response data parsed', responseData);
                
                // Check if response indicates success
                if (responseData.status && responseData.status !== 'success') {
                    throw new Error(`Backend error: ${responseData.message || 'Unknown error'}`);
                }

                // Update exchange status if available
                if (responseData.exchange_status) {
                    updateExchangeStatus(responseData.exchange_status);
                }
                
                // Process the data
                fundingRatesData = processBackendData(responseData);
                
                if (fundingRatesData.length === 0) {
                    updateStatus('üü° No data for tracked symbols', false);
                    debugLog('No data after processing');
                } else {
                    updateStatus(`üü¢ Live: ${fundingRatesData.length} symbols`, true);
                    debugLog('Data processed successfully', { symbolCount: fundingRatesData.length });
                }
                
                renderFundingRatesTable();
                
            } catch (error) {
                debugLog('Failed to fetch funding rates', error);
                
                let errorMessage = 'Connection Failed';
                if (error.name === 'TimeoutError') {
                    errorMessage = 'PythonAnywhere Timeout';
                } else if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    errorMessage = 'PythonAnywhere Offline';
                } else if (error.message.includes('HTTP')) {
                    errorMessage = `Backend Error: ${error.message}`;
                }
                
                updateStatus(`üî¥ ${errorMessage}`, false);
                
                // Show example data
                showExampleData();
            }
        }

        // Show example data when backend is unavailable
        function showExampleData() {
            debugLog('Showing example data');
            
            fundingRatesData = [
                { symbol: 'BTC', binance: 0.0001, kucoin: 0.0002, bybit: 0.0001, okx: 0.0003 },
                { symbol: 'ETH', binance: -0.0001, kucoin: 0.0001, bybit: 0.0000, okx: 0.0002 },
                { symbol: 'SOL', binance: 0.0005, kucoin: 0.0004, bybit: 0.0006, okx: 0.0005 },
                { symbol: 'XRP', binance: 0.0002, kucoin: 0.0003, bybit: 0.0001, okx: 0.0004 },
                { symbol: 'DOGE', binance: 0.0001, kucoin: 0.0002, bybit: 0.0001, okx: 0.0001 }
            ];
            
            updateStatus('üìù Example Data (Backend Offline)', false);
            renderFundingRatesTable();
            updateExchangeStatus({});
        }

        // Main data loading function
        async function loadData() {
            debugLog('Starting data load...');
            
            // Test connectivity first
            const isBackendReady = await testBackendConnectivity();
            if (!isBackendReady) {
                showExampleData();
                return;
            }
            
            // Fetch the actual data
            await fetchFundingRates();
            
            // Auto-refresh every 2 minutes
            setTimeout(() => {
                debugLog('Auto-refresh triggered');
                loadData();
            }, 120000);
        }

        // Force refresh function
        async function forceRefresh() {
            debugLog('Force refresh triggered');
            updateStatus('üîÑ Force refreshing from PythonAnywhere...', false);
            
            try {
                // Try to call refresh endpoint
                const response = await fetch(`${BACKEND_URL}/api/refresh`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    debugLog('Force refresh API called successfully');
                    setTimeout(() => loadData(), 2000);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                debugLog('Force refresh API failed, doing normal refresh', error);
                loadData();
            }
        }

        // Raw data inspector function (for debugging)
        function inspectRawData() {
            fetch(`${BACKEND_URL}/api/funding-rates`)
                .then(response => response.json())
                .then(data => {
                    debugLog('=== RAW DATA INSPECTION ===');
                    debugLog('Full response structure', data);
                    
                    if (data.data && Array.isArray(data.data)) {
                        debugLog('Sample items from data.data', data.data.slice(0, 5));
                        debugLog('Total items in data.data', data.data.length);
                        
                        // Check for tracked symbols
                        const foundSymbols = {};
                        data.data.forEach(item => {
                            const symbol = item.base_symbol || item.symbol?.split('USDT')[0] || item.symbol;
                            if (symbol && trackedSymbols.includes(symbol.toUpperCase())) {
                                if (!foundSymbols[symbol.toUpperCase()]) {
                                    foundSymbols[symbol.toUpperCase()] = [];
                                }
                                foundSymbols[symbol.toUpperCase()].push({
                                    exchange: item.exchange,
                                    rate: item.fundingRate || item.funding_rate
                                });
                            }
                        });
                        
                        debugLog('Found tracked symbols in data', foundSymbols);
                    }
                    
                    debugLog('=== END INSPECTION ===');
                })
                .catch(error => debugLog('Raw data inspection failed', error));
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('DOM loaded, initializing...');
            
            // Load tracked symbols
            loadTrackedSymbols();
            
            // Set up crypto input enter key handler
            document.getElementById('crypto-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addCrypto();
                }
            });
            
            // Add debug toggle (double-click header to enable)
            document.querySelector('.header h1').addEventListener('dblclick', function() {
                toggleDebug();
                if (debugMode) {
                    alert('Debug mode enabled! Check the debug section and console.');
                }
            });
            
            // Start loading data
            updateStatus('üîÑ Initializing PythonAnywhere connection...', false);
            setTimeout(() => {
                loadData();
            }, 1000);
            
            debugLog('Application initialized');
        });

        // Global error handler
        window.addEventListener('error', function(e) {
            debugLog('Global error caught', {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                error: e.error
            });
            updateStatus('üî¥ Application error', false);
        });

        // Network status handlers
        window.addEventListener('online', function() {
            debugLog('Network reconnected');
            updateStatus('üîÑ Reconnecting to PythonAnywhere...', false);
            setTimeout(() => loadData(), 1000);
        });

        window.addEventListener('offline', function() {
            debugLog('Network disconnected');
            updateStatus('üî¥ Offline', false);
        });

        // Helper function to manually test API endpoints
        function testAPI() {
            debugLog('=== MANUAL API TEST ===');
            
            const endpoints = [
                '/health',
                '/api/funding-rates',
                '/api/status'
            ];
            
            endpoints.forEach(endpoint => {
                fetch(`${BACKEND_URL}${endpoint}`)
                    .then(response => {
                        debugLog(`${endpoint} - Status: ${response.status}`, {
                            ok: response.ok,
                            headers: Object.fromEntries(response.headers.entries())
                        });
                        return response.json();
                    })
                    .then(data => {
                        debugLog(`${endpoint} - Data:`, data);
                    })
                    .catch(error => {
                        debugLog(`${endpoint} - Error:`, error);
                    });
            });
        }

        // Make functions available globally for debugging
        window.debugFunctions = {
            toggleDebug,
            inspectRawData,
            testAPI,
            loadData,
            forceRefresh
        };

        console.log('üéØ Debug functions available: window.debugFunctions');
        console.log('üí° Double-click the header to enable debug mode');
    </script>
</body>
</html>
